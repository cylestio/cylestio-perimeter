---
description: Agent Inspector - AI Agent Security Analysis (scan, correlate static ↔ dynamic)
globs: ["**/*.py", "**/*.ts", "**/*.js"]
---

# Agent Inspector Integration

**MCP Server:** `http://localhost:7100/mcp`
**Dashboard:** `http://localhost:7100`
**Proxy:** `http://localhost:4000`

## Available MCP Tools (13 total)

### Analysis Tools
| Tool | Description |
|------|-------------|
| `get_security_patterns` | Get OWASP LLM Top 10 patterns for analysis |
| `create_analysis_session` | Start session for workflow (requires workflow_id) |
| `store_finding` | Record a security finding |
| `complete_analysis_session` | Finalize session and calculate risk score |
| `get_findings` | Retrieve stored findings |
| `update_finding_status` | Mark finding as FIXED or IGNORED |

### Knowledge Tools
| Tool | Description |
|------|-------------|
| `get_owasp_control` | Get specific OWASP control details (LLM01-LLM10) |
| `get_fix_template` | Get remediation template for a finding type |

### Workflow Lifecycle Tools
| Tool | Description |
|------|-------------|
| `get_workflow_state` | Check what analysis exists (static/dynamic/both) |
| `get_tool_usage_summary` | Get tool usage patterns from dynamic sessions |
| `get_workflow_correlation` | Correlate static findings with dynamic runtime |

### Agent Discovery Tools
| Tool | Description |
|------|-------------|
| `get_agents` | List agents (filter by workflow_id or "unlinked") |
| `update_agent_info` | Link agents to workflows, set display names |

## AUTOMATIC WORKFLOW

**When user asks for security analysis, follow this flow automatically:**

### Step 1: Derive workflow_id
Auto-derive from (priority order):
1. Git remote: `github.com/acme/my-agent.git` → `my-agent`
2. Package name: `pyproject.toml` or `package.json`
3. Folder name: `/projects/my-bot` → `my-bot`

### Step 2: Check Current State
```
get_workflow_state(workflow_id)
```

This returns one of:
- `NO_DATA` → Run static analysis
- `STATIC_ONLY` → Inform user to run dynamic tests for validation
- `DYNAMIC_ONLY` → Run static analysis, then correlate
- `COMPLETE` → Run correlation, report unified results

### Step 3: Discover & Link Agents (if dynamic data exists)
```
get_agents("unlinked")
```
If unlinked agents found, link them:
```
update_agent_info(agent_id, workflow_id="the-workflow-id")
```

### Step 4: Based on State

#### Scenario A: Static Analysis First (IDE Code Review)
This is the typical flow when user asks "run a security scan":

1. **Get Patterns**
   ```
   get_security_patterns()
   ```
   NEVER hardcode patterns - always fetch from MCP.

2. **Create Session**
   ```
   create_analysis_session(workflow_id, "STATIC")
   ```

3. **Analyze Code & Store Findings**
   ```
   store_finding(session_id, file_path, finding_type, severity, title, ...)
   ```

4. **Complete Session**
   ```
   complete_analysis_session(session_id)
   ```

5. **Check for Dynamic Data**
   ```
   get_workflow_state(workflow_id)
   ```
   - If state is `COMPLETE`: Run correlation
   - If state is `STATIC_ONLY`: Inform user how to run dynamic tests

6. **Report Results**
   Include dashboard URL: `http://localhost:7100/workflow/{workflow_id}`

#### Scenario B: Dynamic Analysis First (Runtime Captured)
When user ran their agent first, then asks for security review:

1. Check state shows `DYNAMIC_ONLY`
2. Run static analysis (steps above)
3. Correlate with `get_workflow_correlation(workflow_id)`
4. Report which findings are VALIDATED vs UNEXERCISED

### Step 5: Correlation (when both static + dynamic exist)
```
get_workflow_correlation(workflow_id)
get_tool_usage_summary(workflow_id)
```

Report:
- **VALIDATED**: Finding's tool was called at runtime
- **UNEXERCISED**: Tool never called in tests - needs test coverage

### Step 6: Name Agents (optional)
After analyzing code, give agents meaningful names:
```
update_agent_info(agent_id, display_name="Customer Support Bot", description="Handles booking inquiries")
```

## Dynamic Analysis Setup

Tell user to configure their agent's base_url with workflow_id:

```python
# OpenAI
client = OpenAI(base_url=f"http://localhost:4000/workflow/{WORKFLOW_ID}")

# Anthropic
client = Anthropic(base_url=f"http://localhost:4000/workflow/{WORKFLOW_ID}")
```

## Fixing Issues

```
get_findings(workflow_id, status="OPEN")
get_fix_template(finding_type)
# Apply fix
update_finding_status(finding_id, "FIXED", notes="Applied input validation")
```

## Key Rules

1. **Auto-derive** workflow_id - don't ask user
2. **Auto-link** unlinked agents via `update_agent_info`
3. **Auto-correlate** when both static + dynamic data exist
4. **Never hardcode** security patterns - always fetch from MCP
5. **Same workflow_id** for static and dynamic = unified results
6. **Dashboard URL**: `http://localhost:7100/workflow/{workflow_id}`
